{
  "hash": "59c7ce0afbcbac5535736ab68be476ed",
  "result": {
    "markdown": "---\nexecute:\n  eval: false\n  echo: true\n---\n\n\n# Try MOSAIKS {#sec-mosaiks-demo-1}\n\n\n\n:::: status\n::: callout-warning \nThis chapter is in early draft form and may be incomplete.\n:::\n::::\n\n\n<!-- ```{bash}\nquarto convert notebooks/demo/01-MOSAIKS-Internet-example.ipynb\n``` -->\n\n::: {.cell}\n\n:::\n\n:::{.callout-note}\n# Click the badge to run the demo in Google Colab!\n\n&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;  \n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/cullen-molitor/MOSAIKS-Training-Manual/blob/main/notebooks/demo/01-MOSAIKS-Internet-example.ipynb)  \n&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;&uarr;  \n:::\n\nFor instruction on how to use Google Colab, please refer to @sec-intro-compute\n\n<!-- {{< include _01-MOSAIKS-Internet-example.qmd >}} -->\n\n- Description of exercise \n- Video maybe?\n\n## Identifying Internet Access in Togo\n\nThis notebook demonstrates the application of Multi-task Observation using Satellite Imagery & Kitchen Sinks (MOSAIKS), a machine learning approach utilizing satellite imagery, to identify areas with and without internet access in Togo. This information can be crucial for understanding the digital divide and informing policies to improve connectivity.\n\n## Methodology\n\nThe process involves the following steps:\n\n1. **Data Acquisition:** Label data on internet access is provided by the Agence Togo Digital (ATD). Pre-processed satellite imagery features are derived using the MOSAIKS framework.\n1. **Data Preprocessing:** The label and feature data are preprocessed and cleaned. This leaves a single dataset with labels and features that is ready to use.\n1. **Model Training and Evaluation:** A machine learning model, specifically Ridge Regression with isotonic calibration, is trained on the joined dataset to predict the likelihood of internet access. The model is evaluated using metrics like the Receiver Operating Characteristic Area Under the Curve (ROC AUC).\n1. **Visualization and Interpretation:** The model results are visualized using maps and plots. Important features identified by the model are analyzed to understand the patterns associated with internet access.\n\n## Setup\n\nThis notebook utilizes several key Python libraries:\n\n* **Data Handling and Analysis:**  `pandas` and `numpy` provide fundamental data structures and functions for manipulating and analyzing data. `geopandas` extends these capabilities to work with geospatial data.\n* **Visualization:** `matplotlib.pyplot` and `seaborn` enable the creation of static and interactive visualizations, aiding in data exploration and result presentation.\n* **Machine Learning:** `sklearn` offers a comprehensive suite of tools for building and evaluating machine learning models, including algorithms like Ridge Regression and methods for data preprocessing.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nimport shutil\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nfrom google.colab import drive\nfrom sklearn.linear_model import RidgeClassifierCV\nfrom sklearn.calibration import IsotonicRegression\nfrom sklearn.metrics import roc_auc_score, roc_curve\nfrom sklearn.model_selection import train_test_split, GridSearchCV\n```\n:::\n\n\n## Mounting Google Drive\n\nMounting Google Drive in Colab essentially connects your Google Drive storage to the Colab environment. This allows you to access files and folders stored in your Drive directly within your Colab notebook. Think of it as creating a shortcut to your Drive within Colab.\n\n**Why is this necessary?**\n\nColab notebooks run on temporary virtual machines. Mounting your Drive ensures that you can load and save data to your personal storage, persisting even after the Colab session ends. It also enables seamless access to larger datasets stored in your Drive, which would be impractical to upload directly to Colab.\n\nAfter mounting Google Drive, we then define the path to the project folder on Google Drive. This directory contains the data files needed for the analysis.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndrive.mount('/content/drive')\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndrive_directory = os.path.join(\n    \"/\",\n    \"content\",\n    \"drive\",\n    \"Shareddrives\",\n    \"MOSAIKS Workshop\",\n    \"Data\",\n\n)\ndrive_directory\n```\n:::\n\n\n## Create a local directory\n\nThis section creates a local directory within the Colab environment to store the project data. Data files are copied from the Google Drive directory to this local folder.\n\n**Why use a local directory?**  \n\nAccessing data locally on the Colab virtual machine (VM) significantly improves processing speed compared to reading directly from Google Drive. While copying the data initially takes a bit of time, this is outweighed by the performance gains during analysis.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlocal_dir = \"/content/data/\"\n\nos.makedirs(local_dir, exist_ok=True)\n\nfiles_to_copy = os.path.join(drive_directory, \"survey_data\")\n\nshutil.copytree(files_to_copy, local_dir, dirs_exist_ok=True)\n```\n:::\n\n\nHere we take a look at the contents of the local drive to ensure we have the necessary files copied.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n!ls -lh /content/data\n```\n:::\n\n\n## Load in the Internet Access Label Data\n\nThis section focuses on loading and preparing the data on internet access in Togo.\n\n**Initial Loading and Column Selection:** We will load the data from a file and select the relevant columns, such as internet access status and the satellite features.\n\n**Label Data Visualization:** We produce a bar plot to inspect the distribution of labels and check for any imbalances.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata = pd.read_feather(os.path.join(local_dir, \"survey_data.feather\"))\ndata\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndata.groupby('Internet').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))\nplt.gca().spines[['top', 'right',]].set_visible(False)\n```\n:::\n\n\n## Model Training and Evaluation\n\nThis section focuses on training and evaluating a machine learning model to predict internet access using the prepared data.\n\n**1. Data Preparation:**\n\n* The joined dataset is split into features (X) and the target variable (y).\n    * `X` contains the satellite imagery features, specifically the columns with names starting with 'X_'.\n    * `y` contains the internet access label (1 for internet access, 0 for no access).\n* The data is further split into training and testing sets using `train_test_split` to evaluate the model's performance on unseen data.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfeature_cols = [f\"X_{i}\" for i in range(4000)]\n# feature_cols\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nX = data[feature_cols].values\ny = data[\"Internet\"].values\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=1991\n)\n```\n:::\n\n\n**2. Model Selection and Training:**\n\n* A Ridge Regression Classifier model is used for prediction. This model is chosen for its ability to handle high-dimensional data and its robustness to outliers.\n    * Ridge Regression is a linear model that adds a penalty term to the loss function, preventing overfitting.\n* Hyperparameter tuning is performed using `GridSearchCV` to find the best value for the regularization parameter (`alpha`) of the Ridge Regression model. This helps to optimize the model's performance.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nalphas = [0.01, 0.1, 1.0, 10.0]\nridge = RidgeClassifierCV(alphas=alphas, cv=5, scoring='roc_auc')\n\nridge.fit(X_train, y_train)\n```\n:::\n\n\n**3. Model Evaluation:**\n\n* The trained model is evaluated using the testing set, which was not used during training.\n* The primary evaluation metric is the Receiver Operating Characteristic Area Under the Curve (ROC AUC). This metric measures the model's ability to distinguish between positive (internet presence) and negative (internet absence) cases.\n* The ROC curve is visualized to provide a graphical representation of the model's performance across different thresholds.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ny_pred_uncal = ridge.decision_function(X_test)\n\n# Fit isotonic calibration\niso_reg = IsotonicRegression(out_of_bounds='clip')\niso_reg.fit(y_pred_uncal, y_test)\n\n# Get calibrated predictions\ny_pred_cal = iso_reg.predict(y_pred_uncal)\n\n# Calculate AUC scores\nauc_uncal = roc_auc_score(y_test, y_pred_uncal)\nauc_cal = roc_auc_score(y_test, y_pred_cal)\n\nprint(f\"Best alpha: {ridge.alpha_}\")\nprint(f\"AUC before calibration: {auc_uncal:.3f}\")\nprint(f\"AUC after calibration: {auc_cal:.3f}\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Calculate ROC curves\nfpr_uncal, tpr_uncal, _ = roc_curve(y_test, y_pred_uncal)\nfpr_cal, tpr_cal, _ = roc_curve(y_test, y_pred_cal)\n\n# Create the plot\nplt.figure(figsize=(5, 5))\n\n# Plot both curves\nplt.plot(fpr_uncal, tpr_uncal, 'b-', label=f'Uncalibrated (AUC = {auc_uncal:.3f})')\nplt.plot(fpr_cal, tpr_cal, 'r-', label=f'Calibrated (AUC = {auc_cal:.3f})')\n\n# Plot the diagonal reference line\nplt.plot([0, 1], [0, 1], 'k--', label='Random')\n\n# Customize the plot\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('ROC Curves - Before and After Calibration')\nplt.legend(loc='lower right')\nplt.grid(True, alpha=0.3)\n\n# Set the plot limits\nplt.xlim([-0.01, 1.01])\nplt.ylim([-0.01, 1.01])\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport geopandas as gpd\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfeatures = pd.read_feather(os.path.join(local_dir, \"TGO_API_features.feather\"))\n\nfeatures = gpd.GeoDataFrame(\n    features,\n    geometry=gpd.points_from_xy(features.Lon, features.Lat),\n    crs=\"EPSG:4326\"\n  )\nfeatures.geometry = features.geometry.buffer(0.005, cap_style=3)\n\nfeatures\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ny_pred_full = ridge.decision_function(features[feature_cols].values)\n\n# y_pred_full_cal = iso_reg.predict(y_pred_full)\n\nfeatures['predicted_probability'] = y_pred_full\nfeatures\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfeatures[features.predicted_probability > 0].plot(\n    column=\"predicted_probability\",\n    cmap=\"viridis\",\n    legend=True,\n    legend_kwds={'label': \"Predicted Probability\"},\n    figsize=(10, 8)\n)\nplt.title(\"Prediction\")\nplt.xlabel(\"Longitude\")\nplt.ylabel(\"Latitude\")\nplt.show()\n```\n:::\n\n\n## Conclusions\nThis notebook demonstrated the use of MOSAIKS to predict internet access in Togo using satellite imagery features.\n\n**Key Findings:**  \n\n- The model achieved a good level of predictive performance, indicated by the ROC AUC score.\n- Satellite imagery features proved to be valuable predictors of internet access, highlighting their potential for understanding the digital divide.\n\n**Implications and Future Directions:**\n\n- The insights gained from this analysis can inform policy decisions and interventions aimed at expanding internet access in Togo.\n- Further research could explore the use of other machine learning algorithms and incorporate additional data sources to enhance predictive accuracy.\n- This approach can be extended to other regions and countries to address the global digital divide.\n\n**Limitations:**\n\n- The model's performance might vary in different geographical contexts.\n- The accuracy of the predictions depends on the quality and availability of satellite imagery and label data.\n- Further validation and ground-truthing are needed to assess the real-world applicability of the model.\n\n\nOverall, this demonstration highlights the potential of MOSAIKS and machine learning in bridging the digital divide by providing insights into internet access patterns using satellite imagery.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}