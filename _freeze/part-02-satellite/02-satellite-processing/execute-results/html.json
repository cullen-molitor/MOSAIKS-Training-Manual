{
  "hash": "7dc2e3dd2f874e4caf6d31e6ffd95932",
  "result": {
    "engine": "knitr",
    "markdown": "# Processing imagery {#sec-satellite-processing}\n\n\n\n\n:::: status\n::: callout-warning \nThis chapter is in early draft form and may be incomplete.\n:::\n::::\n\n\n\n\n## Overview\n\nAfter selecting appropriate satellite imagery (as discussed in @sec-satellite-imagery), the next step is accessing and processing that imagery for use with MOSAIKS. This chapter covers key considerations and practical approaches for working with satellite data.\n\n## Cloud vs local processing\n\nThere are two main approaches to accessing and processing satellite imagery:\n\n### Cloud-based platforms\n\nModern cloud platforms offer several advantages for satellite image processing:\n\n- No need to download raw imagery\n- Scalable computing resources\n- Pre-configured environments\n- Often include common datasets\n- Pay only for what you use\n\nPopular platforms include:\n\n- Google Earth Engine\n- Microsoft Planetary Computer\n- Amazon Web Services\n- Planet Platform\n- Euro Data Cube\n\n### Local processing\n\nTraditional local processing may be preferred when:\n\n- Internet connectivity is limited\n- Data privacy is paramount\n- Working with proprietary algorithms\n- Computing needs are modest\n- Frequent reuse of same imagery\n\nConsider these factors when choosing:\n\n- Data volume\n- Processing complexity\n- Budget constraints\n- Time requirements\n- Security needs\n\n## Accessing imagery\n\n### Cloud platforms\n\n#### Google Earth Engine\n\n```python\nimport ee\nee.Initialize()\n\n# Get Sentinel-2 imagery\ns2 = ee.ImageCollection('COPERNICUS/S2_SR')\n  .filterDate('2019-01-01', '2019-12-31')\n  .filterBounds(region)\n```\n\n#### Microsoft Planetary Computer\n\n```python\nimport planetary_computer as pc\nimport pystac_client\n\n# Access STAC API\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=pc.sign_inplace,\n)\n```\n\n### Local downloads\n\n#### Sentinel-2\n\n```python\nfrom sentinelsat import SentinelAPI\n\n# Connect to Copernicus Open Access Hub\napi = SentinelAPI('user', 'password')\n\n# Search and download\nproducts = api.query(\n    area,\n    date=('20190101', '20191231'),\n    platformname='Sentinel-2'\n)\n```\n\n#### Landsat\n\n```python\nimport landsatxplore.api\n\n# Initialize API\napi = landsatxplore.api.API('user', 'password')\n\n# Search scenes\nscenes = api.search(\n    dataset='landsat_ot_c2_l2',\n    bbox=bbox,\n    start_date='2019-01-01',\n    end_date='2019-12-31'\n)\n```\n\n## Processing steps\n\n### 1. Quality assessment\n\n- Cloud detection\n- Shadow masking\n- Bad pixel identification\n- Sensor artifacts removal\n\n### 2. Atmospheric correction\n\n- Convert to surface reflectance\n- Account for atmospheric effects\n- Standardize across images\n\n### 3. Geometric correction\n\n- Orthorectification\n- Co-registration\n- Projection alignment\n\n### 4. Mosaicking\n\n- Image stitching\n- Feathering/blending\n- Gap filling\n- Color balancing\n\n### 5. Temporal compositing\n\n- Best-pixel selection\n- Weighted averaging\n- Gap filling\n- Smoothing\n\n## Processing workflows\n\n### Example cloud-based workflow\n\n```python\ndef process_sentinel2(aoi, start_date, end_date):\n    \"\"\"\n    Process Sentinel-2 imagery on Google Earth Engine\n    \n    Parameters:\n    -----------\n    aoi : ee.Geometry\n        Area of interest\n    start_date : str\n        Start date (YYYY-MM-DD)\n    end_date : str\n        End date (YYYY-MM-DD)\n        \n    Returns:\n    --------\n    ee.Image\n        Processed composite image\n    \"\"\"\n    s2 = ee.ImageCollection('COPERNICUS/S2_SR') \\\n        .filterBounds(aoi) \\\n        .filterDate(start_date, end_date)\n    \n    # Cloud masking\n    def mask_clouds(img):\n        clouds = img.select('QA60').bitwiseAnd(1 << 10)\n        return img.updateMask(clouds.Not())\n    \n    # Apply cloud mask\n    s2_masked = s2.map(mask_clouds)\n    \n    # Create median composite\n    composite = s2_masked.median()\n    \n    return composite\n```\n\n### Example local workflow\n\n```python\ndef process_local_images(image_dir):\n    \"\"\"\n    Process downloaded satellite imagery\n    \n    Parameters:\n    -----------\n    image_dir : str\n        Directory containing images\n        \n    Returns:\n    --------\n    numpy.ndarray\n        Processed image array\n    \"\"\"\n    import rasterio\n    from rasterio.merge import merge\n    \n    # List images\n    images = []\n    for file in os.listdir(image_dir):\n        if file.endswith('.tif'):\n            with rasterio.open(os.path.join(image_dir, file)) as src:\n                images.append(src)\n    \n    # Merge images\n    mosaic, transform = merge(images)\n    \n    return mosaic\n```\n\n## Best practices\n\n1. **Document everything**\n   - Processing steps\n   - Parameter choices\n   - Quality control decisions\n   - Software versions\n\n2. **Validate outputs**\n   - Visual inspection\n   - Statistical checks\n   - Ground truth comparison\n   - Cross-platform verification\n\n3. **Optimize resources**\n   - Batch processing\n   - Parallel computing\n   - Memory management\n   - Storage efficiency\n\n4. **Version control**\n   - Track code changes\n   - Archive key datasets\n   - Document dependencies\n   - Maintain reproducibility\n\n## Common challenges\n\n### Storage requirements\n\n- Raw imagery can be massive\n- Multiple processing steps multiply storage needs\n- Intermediate products management\n- Backup considerations\n\n### Computing resources\n\n- Processing can be CPU/GPU intensive\n- Memory limitations\n- I/O bottlenecks\n- Network bandwidth\n\n### Quality issues\n\n- Cloud contamination\n- Atmospheric effects\n- Sensor artifacts\n- Geometric distortions\n\n### Time management\n\n- Processing can be slow\n- Download times\n- Quality checking\n- Iteration cycles\n\n## Future considerations\n\nAs you develop your processing pipeline, consider:\n\n- Scalability needs\n- Automation opportunities\n- Quality control requirements\n- Resource constraints\n- Time limitations\n\n::: {.callout-note}\n# Looking forward\n\nIn the next section, we will explore how to extract MOSAIKS features from processed imagery.\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}